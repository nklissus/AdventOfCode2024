# Advent of Code 2024
This repository will be used to store my work for the 2024 installment of [Advent of Code](https://adventofcode.com/2024). I'm refreshing my basic Ruby skills this year so it might be slow going at first, but it's good to keep these skills fresh.

## Day 01
Pretty simple task to start off. Ruby makes it really easy to interact with arrays so this is as simple as reading each line and converting them to arrays. Part 2 is actually even easier than Part 1 since we don't have to sort the arrays.

## Day 02
A little bit more complex and I'm sure there's a better way to structure the code, but this problem was as simple as identifying any "bad" lines given a certain set of parameters. Part 2 adds a little challenge since we have to go back and reevaluate those "bad" rows but converting the evaluation logic into a function made it pretty easy. A big thing I got caught up on was that Ruby doesn't implicitly create copies of arrays (like Python might) and you have to explicitly use the `.dup` function of an array to create a copy.

## Day 03
This one immediately screamed "regex" so that was the tactic I started with. It ended up being very straight forward except that Ruby uses `..` instead of `,` when slicing strings but once I got that dialed in it was done. Part 2 just required a couple additions to the regex expression. The sample input was different for part 2 which tripped me up until I noticed, but once I updated that it worked on the first try.

## Day 04
A classic AOC problem that involves making a matrix. I went with my standard array of arrays to hold all the values. The search logic took a little longer than it should have since you have to have the correct letters in the correct order but it was pretty straight forward after I got that straightened out. Ruby has some pretty cool assignment operators (`<<` for adding to arrays) and logic shorthand (`next unless`, `count += 1 if valid`, `next_m.all? {}`, etc.). It's hard to think to use them on the fly, but they make the code much easier to read after a cleanup pass

## Day 05
Today took me a bit to undestand the logic but once I figured out how to structure the rules (in a `Hash` which you have to initialize explicitly in Ruby) I could check each update row pretty easily. Part 2 definitely took me a bit and my initial thought was to just iterate through each permutation of each update row (I should know better, permutations are never the answer in AOC). But once I'd taken a second look at how the rules were structured I discovered that I just had to find which "pages" had the most "pages" after them based on the rules and could then order them that way. It still felt kind of messy, but I did learn some more Ruby tricks (in numeric ranges `(#..#)` is inclusive of the last number and `(#...#)` is exclusive of the last number, and you can often add `unless` after a line to conditionally perform it -- including assignments) so it felt ok.

## Day 06
The general premise seemed pretty straight forward today and part 1 was not too bad. I used the Ruby `cycle` feature to loop through an array of directions since the guard always turns right, this let me call `array_name.next` to get the next element of an array looping back around the first one once I got to the last. A flood fill algorithm might have been more efficient, but my naive method worked well enough. Part 2 was a little bit harder until I figured out that obstructions could only be placed in the locations identified in part 1, but this still resulted in almost 5,000 possible positions so my loop identification function ended up being kind of slow at scale. It still completed in less than 30 seconds so I'm satisfied with it for now.

## Day 07
I was my own worst enemy today. The problem was fairly easy to understand and execute: evaluate permutations of operations and see if any make the values equal the total. I know I said on Day 5 that permutations are never the answer but I couldn't see any other way today so I went ahead and implemented an array of all possible permutations of operations. The problem is there were only 2 operators and Ruby's `permutation` won't return an array longer than its input array so I created an array with a `+` and `x` for each possible location. This meant I had a ton of repeat permutations, but it worked on the test input so I tried it anyway. I let the code run for quite a while and thought there must be some way that didn't require permutations, but I couldn't figure it out. After doing a little more digging, it turns out Ruby already has a solution to my problem: `repeated_permutation` which can create a longer output array and all possible permutation for any smaller array. Once I switched that in Part 1 had completed in less than a minute. Once I got that figured out Part 2 only required adding another operator and was done computing in a little over a minute. Part 2 took almost exactly 6 minutes after finishing Part 1!

## Day 08
Today wasn't so bad, it's a problem mainly involving planar geometry. Find the distance between each set of antennas and place antinodes the same distance from each antenna in that pair. The longest part of this was remembering that I had to find the distance first and then add that to the coordinates of the original antenna, but once I did that it basically solved itself. Part 2 just involved doing this for every possible further distance within the grid. I kind of brute forced this and just found potential antinodes points as if the antennas were right next to each other; this resulted in many invalid antinode locations, but the code finished fairly fast so I only checked validity after I'd found all possible antinode locations (including invalid ones outside the grid). If I were to clean this up and make it more efficient I'd stop finding new antinodes once they were outside the grid and probably used a `set` instead of an `array` to keep track of valid antinodes since I only care about unique locations.

## Day 09
Oh man, a day of terrible debbugging. Part 1 seemed easy enough and I though I had a plan pretty quickly: recreate the file data as a string and just manipulate that to find the compact file data. This worked well on the test input, but failed completely on the puzzle imput and took way longer than I expected to run. It took me quite a while but I realized it was because the test data on had file IDs that went up to 9 and once the IDs were multiple digits the file data string could no longer be parsed character by character. I ended up using an array to track the file data and spaces, but it took way longer than I would have liked. Part 2 was a nightmare; it seemed like I would just have to change my logic and it would work and I quickly had a fairly effective solution, but my answer ended up being too high. I figured my logic must have been wrong and started over all the way from scratch. After far too long I had another solution that worked with the test data and I was sure it would work with the puzzle input... it did not... in fact, I got the same answer that was too high! After way to much debugging and logic reworks I kept getting the same wrong answer, but finally I realized that although I was properly tracking file movement and spaces I had failed to make sure I was only moving files to empty positions with a lower index. Once I checked to make sure I didn't move any files to the right I finally had the correct answer. My code is horribly inefficient and takes several minutes to complete but I don't feel like reworking it and if I had the correct index checking logic originally it would probably be good enough and faster than what I ended up with. Lesson learned: logic is tough when fatigued, and debugging is even tougher.

## Day 10
Today did not feel like day 10, it was relatively easy and I was done with both parts in less than an hour. Today we're mapping hiking trails which I represented as a matrix and just searched for the next valid position and added it to an array. My first instinct ended up working since any branching paths were represented in the array and since the function just looked for all valid positions around the current position I didn't have to use any recursion to trace branching trails individually. Part 2 was extremely easy since I accidentally found the solution while testing Part 1 so I ws able part 2 three minutes after completing Part 1. One interesting thing of note that made me question my code: Ruby seems to convert non-numeric characters to `0` when using `to_i` which can be an easy issue to overlook if you're dealing with any significant amount of data and don't expect non-numeric characters to be present.

## Day 11
*"Oh, a list of rules and a short input string? This should be easy."*

And Part 1 was fairly easy, I just used an array to track the current stone values and perform the transformation on each stone for 25 cycles. This worked fine and completed in less than 5 seconds. But Part 2 requires 75 cycles and the array is already 218,079 items long after 25 cycles (starting with only 8 items) so using an array to track stone values was not going to work; after about cycle 30 the script slowed to a crawl. After looking at the internal patterns of transformations during each cycle and trying to see if there was any way to track them I had the idea of using a hash to track the count for each value in the array, this would be good for tracking values and just tallying those for any patterns I found instead of leaving them in the array and transforming them there. While testing the hash I decided to see how it stacked up against the array method I'd used in Part 1, and it was way faster so I tried it against the test data for 75 cycles and it finished in less than a second so I figured, *what the hell, let's try it against the puzzle data* and... it worked in less than a second. 

Using a hash to tally values is really effective and I should think about using them more when I'm likely to see repeating values and their position doesn't matter. Ruby arrays even have a `tally` method that creates a hash with unique values as keys and their count as values. Also, to define a default value for newly initialized keys in a hash you just put it after the hash declaration (`Hash.new 0`); in previous days I'd been using a mapping function.